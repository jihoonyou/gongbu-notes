# day 4 파이썬 기초 문법 III

## Python Object Oriented Programming

### 수강신청 프로그램 작성
- 수강신청이 시작부터 끝까지 순서대로 작성
    - 함수단위로 만들어서
- 수강신청 관련 주체들(교수, 학생, 관리자)의 행동(수강신청, 과목 입력)과 데이터(수강과목, 강의 과목)들을 중심으로 프로그램 작성 후 연결
    - 각 객체로 만들어서

### 객체지향 프로그래밍 개요
- OOP
- 객체: 실생활에서 일종의 물건, 속성(Attribute)와 행동(Action)을 가짐
    - 속성: 변수(variable)
    - 행동: 함수(method)
- OOP는 설계도에 해당하는 class와 실제 구현체인 instance로 나눔
    - 붕어빵틀(class) -> 붕어빵(instance)

### class 선언하기
- class 선언, object는 python3에서 자동 상속
- `class SoccerPlyaer(object)`
    - object는 자동상속(안적어도 됨)
- 함수/변수: snake_case
- 클래쓰: CamelCase

### Attribute 추가하기
- attribute 추가는 `__init__`, `self`와 함께
    - `__init__`은 객체 초기화 예약 함수
 ```
 class SoccerPlyaer(object):
    def __init__(self, name, position, back_number):
        self.name = name
        self.position = position
        self.back_number = back_number
 ```

 ### 파이썬에서 __의미
 - __는 특수한 예약 함수나 변수 그리고 함수명 변경(맨글링)으로 사용
    - ex) `__main__ __str__ __add__ __eq__`
- [참고](https://corikachu.github.io/articles/python/python-magic-method)

### method 구현하기
- Method(Action) 추가는 기존 함수와 같으나, 반드시 self를 추가해야만 class 함수로 인정됨
    
### objects(instance) 사용하기
- object 이름 선언과 함께 초기값 입력하기
- 객체명 = class명 __init__함수 interafece, 초기값
    - self는 생성된 instance 자신 
        - 밖에서는 객체명이지만, 코드안에서 자기 자신을 가르킬 때
- 객체 내의 attribute를 객체명.atrribute명으로 바꿀 수 있지만 권장하지 않음

### 상속(Inheritance)
- 부모클래스로부터 속성과 method를 물려받는 자식 클래스를 생성하는 것
```
class Person:  # 부모 클래스 Person 선언
    def __init__(self, name, age, gender):
        self.name = name  # 속성값 지정, 해당 변수가 클래스의 attribute임을 명확히하기 위해 self를 붙임
        self.age = age
        self.gender = gender

    def about_me(self):  # Method 선언
        print("저의 이름은 ", self.name, "이구요, 제 나이는 ", str(self.age), "살 입니다.")


class Employee(Person):  # 부모 클래스 Person으로 부터 상속
    def __init__(self, name, age, gender, salary, hire_date):
        super().__init__(name, age, gender)  # 부모객체 사용
        self.salary = salary
        self.hire_date = hire_date  # 속성값 추가

    def do_work(self):  # 새로운 메서드 추가
        print("열심히 일을 합니다.")

    def about_me(self):  # 부모 클래스 함수 재정의
        super().about_me()  # 부모 클래스 함수 사용
        print("제 급여는 ", self.salary, "원 이구요, 제 입사일은 ", self.hire_date, " 입니다.")


myPerson = Person("John", 34, "Male")
myEmployee = Employee("Daeho", 34, "Male", 300000, "2012/03/01")
myPerson.about_me()
myEmployee.about_me()
```
- super는 부모 객체를 불러옴
    - self는 자기자신

Polymorphism
> 같은 이름 메소드의 내부 로직을 다르게해서 상속
> 메소드 이름이 같은데 행동이 다르게

Visibility(Encapsulation)
> 객체의 정보를 볼 수 있는 레밸을 조정
> 누구나 객체 안에 모든 변수를 볼 필요가 없음
- 캡슐화 또는 정보 은닉
```
class Product(object):
    pass

class Inventory(object):
    def __init__(self):
        self.__items = []

    def add_new_item(self, product):
        if type(product) == Product:
            self.__items.append(product)
            print("new item added")
        else:
            raise ValueError("Invalid Item")

    def get_number_of_items(self):
        return len(self.__items)


my_inventory = Inventory()
my_inventory.add_new_item(Product())
my_inventory.add_new_item(Product())
print(my_inventory.get_number_of_items())

print(my_inventory.__items)
my_inventory.add_new_item(object)
```
- 여기서 __ private

```
class Product(object):
    pass

class Inventory(object):
    def __init__(self):
        self.__items = []

    def add_new_item(self, product):
        if type(product) == Product:
            self.__items.append(product)
            print("new item added")
        else:
            raise ValueError("Invalid Item")

    def get_number_of_items(self):
        return len(self.__items)

    @property
    def items(self):
        return self.__items


my_inventory = Inventory()
my_inventory.add_new_item(Product())
my_inventory.add_new_item(Product())
print(my_inventory.get_number_of_items())

items = my_inventory.items
items.append(Product())
print(my_inventory.get_number_of_items())
```
- @property decorator로 items의 접근 허용
    - 함수를 변수명처럼 쓸 수 있게
- 하지만 my_inventory.items.append()로 수정이 되기 때문에, deepcopy를 해서 반환해주는게 일반적임

### decorator

### first-class objects
- 일등함수 또는 일급 객체
- 변수나 데이터 구조에 할당이 가능한 객체
- 파라메터로 전달이 가능 + 리턴 값으로 사용
- 파이썬의 함수는 일급함수
    - 함수자체가 parameter나 리턴값으로 쓰일 수 있음
```
def sqaure(x):
    return x*x
f = sqaure # 함수를 변수로 사용
f(5)

def cube(x)
    return x*x*x

def formula(method, argument_list):
    return [method(value) for value in argument_list]
```

### Inner function
- 함수 내에 또 다른 함수가 존재
```
def print_msg(msg):
    def printer():
        print(msg)
    printer()

print_msg("hello, python")
```
- closure: inner function을 return값으로 반환
```
def print_msg(msg):
    def printer():
        print(msg)
    return printer
another = print_msg('hello, python')
another()
```
- 같은 목적 다양한 변형에 사용
```
def tag_func(tag, text):
    text = text
    tag = tag

    def inner_func():
        return '<{0}>{1}<{0}>'.format(tag, text)
    
    return inner_func
h1_func = tag_func('title', "this is pyhton class")
p_func = tag_func('p', "data Academy")
```

## Module and Project

### 모듈과 패키지
- 모듈은 하나의 패키지 안에 들어가 있음

### module
- 어떤 대상의 부분 혹은 조각
    - ex) 레고 블록, 벽돌, 자동차 부품들
- 합쳐서 만들걸 패키지, 공개하는걸 project
- 프로그램에서는 작은 프로개름 조각들, 모듈들을 모아서 하나의 큰 프로그램을 개발
- 프로그램을 모듈화 시키면 다른 프로그램이 사용하기 쉬움

### 모듈 in python
- built-in module
    - `import random`

### 패키지
- 모듈을 모아놓은 단위, 하나의 프로그램
    - 패키지를 공개하는 것을 프로젝트

### 모듈 만들기 
- 파이썬의 module == py 파일
- 같은 폴더에 module에 해당하는 .py파일과 해당하는 .py파일과 사용하는 .py을 저장한 후
- import 문을 사용해서 module을 호출
`import fah_converter`
- fah_converter.py에 있는 모든 코드가 메모리로 로딩
- 같은 폴더안에 있어야함

 __pycache__
 - 컴파일된 파이썬 파일, pyc - python compile
    - 내코드를 더 빨리 메모리 로딩하기 위해서 컴파일 시켜줬구나

### namespace
- 모듈을 호출할 때 범위 저앟는 방법
- 필요한 내용만 골라서 호출할 수 있음

### namespace example
- Alias 설정 -> 이거를 추천
- 특정 함수 또는 클래스만 호출
- 모든 함수 또는 클래스를 호출

### Built-in modules
> 파이썬이 기본 제공하는 라이브러리
> 문자처리, 웹, 수학 등 다양한 모듈이 제공됨
> 별다른 조칭벗이 import 문으로 활용 가능

### 패키지
> 하나의 대형 프로젝트를 만드는 코드의 묶음
> 다양한 모듈들의 합, 폴더로 연결됨
> __init__, __main__ 등 키워드 파일명이 사용됨
> 다양한 오픈 소스들이 모두 패키지로 관리됨

### 패키지 만들기
from sound import echo
- 폴더에 있으면 from으로 불러 낼 수 있음 

폴더별로 __init__.py 구성하기
- 현재 폴더가 패키지임을 알리는 초기화 스크립트
- 없을경우 패키지로 간주하지 않음 (3.3+ 부터는 상관 없음)
- 하위 폴더와 py 파일(모듈)을 모두 포함

### Python Virtual Environment Overview
- 프로젝트 진행 시 필요한 패키지만 설치하는 환경


## 피어 세션 정리
- https://paperswithcode.com/ 에서 methods 에서 code snipit

### 피어세션 발표
### A - Hash Table
- key value
- hash function
- collision
    - linear probing
    - chaining

### B - deep copy
mutable와 immutable object에 관한 shallow copy에대 한 설명.
deep copy module의 사용이유 (2D이상일경우)
- 하지만 속도가 느리며, 다중 iteration으로 대체하여 사용

### C - ChainMap
Collectino ChainMap에 대한 설명
- update시 더 빠름

### D - deque vs. list
파이썬의 deque와 list의 속도차이 이유
- list realloc에 대한 설명

### E - Iteration
반복문 속도 비교

### (본인) Iterator & Iterable에 대한 설명을 진행

### 피어세션 리뷰
다들 발표를 열심히 준비해주셔서 항상 너무 유익한 시간이 되는 것 같다. Iterator에 대한 설명을 하면서 질문을 받았는데 생각보다 매끄럽게 답변을 하지 못한게 아쉬움이 남는다. 발표 준비전 해당 부분을 꽤 오랜시간 공부했는데..ㅠ 내일은 더 좋은 정보를 나누고 싶다.
모든 팀원분들이 다 열심히 하는 분들이고 너무 좋다 :) 
오늘도 CIFAR-18조 화이팅!

## 과제 리뷰
morsecode
- 과제를 진행하면서 함수의 input의 ' '의 처리하는 조건을 잘못이해하여 디버깅하는데 시간이 좀 걸렸다. 그래도 조건을 잘못이해하는 바람에 python에서 reduce함수를 사용할 기회가 있었는데 해당 함수에 대한 이점을 좀 생각해볼 시간을 가져야겠다.