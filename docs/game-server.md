# game-server-study

## 개요
- 생각보다..? 아마도 키워드가 잘못되었는지.. C# 게임 서버 개발 정보가 없는 것 같습니다.
- 일단.. 찾은 자료를 기반으로 무작정 따라해보려고 합니다!!

### Tucker Programming - game networking

#### 게임 네트워킹의 이해 - 1 네트워킹이란?
- 네트워킹: 데이터를 주고 받는 것
    - 컴퓨터내부: HDD -> RAM -> CPU -> RAM -> HDD
    - PC -> amazon.com
    - 차이점
        1. 지연시간(latency) (내부는 전선으로 연결되고 빨라서 latency가 적음 // 외부 컴퓨터끼리는 latency 발생)
            - ping: 네트워크 지연속도 (내가 응답을 보냈을 떄, 응답이 걸리는 속도 ex) 100ms 왕복시간)
                - RTT (round trip time)
            - 격투게임 서버가 지구 반대편에 있다면 (지구 반대편까지 가는 시간 133ms = 0.13초)
                - 보통 격겜은 Frame 1/30, 1/60. 초당 30장 또는 60장이 그려진다
                - 주먹을 누르고 133ms 후에 주먹이 나가는 것 (8 frame 이후에 주먹이 나간다: 격투게임에서는 매우 느린 속도)
                - latency 눈속임이 필요
                    - 물리적인 한계이기 떄문에 줄일 수 없음
                    - 133ms 빛 가장 빠른속도 (이상적인 속도이므로.. 보통은 500ms + 600ms)
        2. 연결안정성 - 실제 인터넷에서 연결거점이 문제가 생겨서 연결이 끊어질 수 있음
            - 가는 거점이 여러개다 보니 연결이 불안정할 수 있음
            - 게임네트워크에서 연결이 끊기는 상태를 잘 커버하는게 중요
        3. 순서비보장 (CPU에서 RAM은 광자로 순서대로감 / 하지만 인터넷에서는 순서가 섞일 수 있음)
            - WWW에서 다양한 거점을 통해 가기 때문에
            - 데이터를 살포해보고 가장 빠른 네트워크길을 캐싱해둬서 기억하고, 그 곳으로 보냄
            - 순서 패킷을 잘 보장하는 것이 관건

#### 게임 네트워킹의 이해 2 - Protocol TCP/UDP
- Network Protocol 통신 약속/규약
- 게임에서는 
    - TCP,UDP (상위 layer) 아마 transport layer말하는듯
    - IP (하위 layer) 아마 networki layer
- 보내는쪽 layer를 지날때마다 데이터 추가
- 받는쪽 하나씩 떼어내며 확인
- IP는 컴퓨터의 주소
- 전송되면 GATEWAY (10.10.0.0) -> 10.10다 나한테
- 보통 IP와 port를 적어서 보냄
    - IP는 어떤 컴퓨터냐, port는 어떤 터미널이냐
- 통신에서는 송신도 잘하고 수신도 잘해야함
- TCP
    - 연결 유무 확인 
        - 3 way handshake
            - connect request ->
            - <- OK
            - good -> 
            1. 답장을 몇번 보내도 답이 안오면 끊어진 것
            2. 아니면 끊어졌다를 통보 받음
    - 순서 보장
        - 여러개를 보낼 때, 번호를 메겨서 보냄
    - 송신 보장
        - 중간에서 안보낸 것을 다시 보내라고 말함
- UDP
    - 연결유무 - x 
    - 순서보장 - x
    - 송신보장 - x
- TCP threeway handshake때문에 3배 느림
    - 지연시간이 느림
- UDP 빠름
    - 유실은 보통 7%
    - 지연시간 ok
    - 만약에 궁을 썼는데 유실되서 안된다면..
    - Reliable UDP (TCP가 하던일을 개발자들이 software로 처리)
        - 만들기 어려워서 대형회사 또는 unity, unreal에서 제공! + open source도 있음
- TCP (H/W처리), Reliable UDP(S/W처리)
- 대부분의 게임들을 UDP 사용
    - ex) 격투게임, 슈팅게임, LOL, 오버워치, 스타크래프트
- TCP
    - MMORPGT, 보드게임...

#### 게임 네트워킹의 이해 3 - Deterministic 방식
- TCP
    - 반응성이 느리지만 안정적인 connection을 유지해야하는 게임 (MMORPG, 보드게임..)
- UDP
    - 나머지 게임들
- 데이터를 어떻게 보내 어떻게 활용할 것인지
- Deterministic (전송부분)
    - UDP
    - 반응이 빠른 게임
- Server Authority (활용부분) 서버에 권한을 주는 것 
    - TCP
    - 서버에 권한이 많이 필요한 경우
    - MMORPG에서 부정 방지
- Deterministic과 Server Authority의 관계는 없는 부분

- Deterministic: 같은 입력이 들어가면 결과는 같다 (이미 결정되어 있는) 
    - 게임기가 한대(철권 오락기 한 대): 내부에 전선 입력이 두 개 (two player)
        - 입력값이 들어가면, 안의 게임은 60fps (1초에 60장의 이미지를 그리는 것), 매 한장 그릴때마다 변경된 것이 적용되어 그려짐
            - punch를 입력하면, 다음 frame부터 펀치가 날려짐 
                - 4frame에 날라간다하면 4장에 걸쳐 나가는거 표현
                - 누가 한 frame이라도 먼저 빠릴 눌렀냐에 따라 빠르게 펀치가 나감
    - 서로 다른게임기(붙어있는 철권오락기): 하나의 전선 입력에 서로 다른 두 개의 게임기의 연결
        - 버튼이 누르면, A컴퓨터 B컴퓨터 각자 펀치가 들어감
            - 두 게임기가 붙어있으면, 같은 입력이 동시에 들어감 = 결과가 값다
            - 결과가 같으려면, 같은 환경이라는 가정이 필요
    - **같은 입력이 같은시간에 들어가도록 만들면, 결과는 같다**
        - 즉, 지연시간을 극복해야함!
        - Ex) 지연시간이 150ms라면, 입력 후 150ms를 기다린 후 입력 처리
        - 서로 도착하는 시간의 지연시간 만큼 기다릴 경우, 같은 결과를 얻을 수 있음

#### 게임 네트워킹의 이해 4 - Delay 와 Rollback
- deteriminstic은 desync가 안나게 만드는 것!
    - Delay
        - 각 플레이어의 입력에 지연시간(latency)만큼 delay를 주는 것
        - 두 컴퓨터의 sync를 만춰주는 것
        - 문제점: delay가 되는 것 (100ms가 마지노선인듯 //200ms은 일반인이 충분히 느낌)
    - rollback
        - P1과 P2가 다른 그림을 그리고 있음 (desync)
        - 입력이 도착하면 latency만큼 시간을 rollback
        - 상대방의 입력이 들어오는 순간 롤백해서 싱크를 맞추는 것
        - 문제점: 
        1. P2입장에서 내가 때렸는데, 내가 맞는 상황으로 바뀜 (내가 먼저 쐈는데 내가 맞았다가 되는 상황 - 렉사)
        2. 만들기가 어려움(뒤감기 -> 앞감기, 입력을 중간에 집어넣기, 기록도 해야됨(메모리 복잡성 증가))
            - 2인용 격투게임에서는 괜찮지만, 10~20명에서는 더 복잡해짐
        - 보통은 Delay & Rollback을 섞어서 사용하고 rollback을 제한적으로 사용
            - ex) 오버워치에서 rollback기능 가능 캐릭터가 있음
            - ex) lol에서 replay기능이 있음
        3. 중간 접속 처리가 어려움
            - state를 기록하는 것이 아닌, 입력을 주고받기 떄문에
            - deterministic에서 reconnect기능을 구현하기가 어려워서 안하는 경우도 있음
            - 상태를 공유하지않으므로, desync를 맞추기 힘듦. 살짝 차이가 나면 시간이 갈수록 오차범위가 늘어나기 때문

#### 게임 네트워킹의 이해 5 - 다른 유용한 방식들
- 중계서버 (Relay Server, broadcast server)
    - 받은 패킷을 그대로 전달하는 것
    - 버튼을 누르면 서버에 보내고, 각 플레이어 다시 전달하여 그 것을 기반으로 처리
    - 서버는 시간을 일정간격으로 쪼개고, 해당 시간에 온 입력들을 모아서 한번에 보내줌(timeslot)
        - 턴제 같은 느낌 (ex. 포커)
        - 게임에서 1초에 30번
    - 문제점: 입력 0ms -> 100ms 서버로 -> 30ms 서버에서 gathering -> 다시 client로 100ms이면 delay가 230ms..
        - 패킷이 갔다가 돌아와야 처리가 되므로, 사용자 입장에서 좀 ..

- rollback
    - 반응성이 좋고, desync발생 가능, 복잡성이 높음
    - 격투, FPX
        - 다른 구현방법: 입력이 오든 안오든 매 프레임마다 일정 프레임만큼 롤백하는 것 (구현이 단순해짐// 기존에는 특별한 경우에 롤백하는 것과 다름)
            - rollback을 잘 구현했다면 성능상 이슈가 많지 않음(게임에서 성능을 가장 많이 차지하는 부분은 그래픽)
- 중계서버
    - desync문제 적고, 반응성이 낮음
    - AOS, 스포츠

- deterministic: 같은 iniput이면 같은 결과가 나온다는 것을 보장
    1. 같은 input을 맞추는 방법에 delay와 rollback이 있다
    2. 중계서버를 사용한 relay server방식이 있다
    3. 매 프레임마다 정해진 싸이클 만큼 롤백하는 방법도 많이 사용 한다 (쉬운 구현)

#### 게임 네트워킹의 이해 6 - P2P, Relay 서버 방식
- P2P: client끼리 직접 연결하는 방식
    - 격투게임
    - 5명이라면.. 
        - 방장이 모든 connection을 갖는 방식 
            - 방장이 중심으로 관리하면 각 client별로 방장과의 하나의 연결만 관리하면되는 장점이 있음 // 방장이 심판 역할 가능
            - 단점: 방장이 나가거나 connection이 끊길 경우, 방이 폭파되는 상황 발생
                - 새로운 방장을 뽑는 방식도 있음 (하지만, 구현이 까다로운듯)
        - fully conenction 방식
            - 서로 모두 연결
            - 단점: 각 client가 관리해야하는 connection수가 많음
            - 장점: 누가 나가더라도, 문제없이 플레이 가능
- Relay server: 정해진 서버에 client들이 접속
    - 장점: 
        - 서버가 잘 끊어지지 않는 장점
        - 해킹에 둔감
    - 단점:
        - 서버가 다운되면 게임이 안됨
- P2P의 가장 큰 문제점
    - IPv4를 계속 사용 하는 이유: IP Mapping
        - 맨 앞에 gateway만 고정 IP, 안에서 분배되어지는 IP는 고정IP일 필요없음
            - packet이 나올 수 있는데 반대로 들어올 수는 없음
            - 집에서 접속할 때, 외부 네이버 IP를 알기 떄문
                - TCP의 경우 서로 연결을 맺기 때문에 packet을 주고 받을 수 있음
                - UDP는 보내기만 가능
    - client(peer)끼리 정확한 고정ip를 모르기 때문에 P2P가 안됨
        - 그럼 P2P불가능? 홀펀칭으로 구현 가능(백도어를 구멍을 뚫는 것)
    - 왜 IPv4? 이게 꽉차는 상황이 발생할까봐 IPv6를 추후에 고안했지만, IP Mapping으로 인해 각 client들이 고정IP를 갖지 않음

#### 게임 네트워킹의 이해 7 - 홀펀칭 그 신박한 세계
- private ip는 언제든 바뀔 수 있음 (근데 이것은 외부에서 알 수 없음)
    - gateway의 역할은 보호기능과 IPv4 고발방지
        - [gateway가 할당한 portzz,출발위치+포트에, 목적지]에 대한 mapping table을 만듦(바깥쪽으로 나갈 때) 
            - 네이버는 출발한 위치(gateway)와 port만 앎 -> 그럼 mapping table로 확인해서 전해줌
            - 네이버는 gateway가 나갈 떄 사용한 port(terminal)로 packet을 보내는거. 즉, 처음 client의 주소 port와 네비어가 보낸이로 알고 있는 ip, port가 다름!

- hole punching은 두 클라이언트가 (stun server)특정 서버를 통해서, 서로의 public gateway와 나갔던 Port를 알려주어(연결?) 직접 서로 pakcet을 주고 받는 것 
    - 여기서 gateway가 낯선 목적지의 데이터를 받을지 말지는 구현의 문제 (대부분 받음)
    - NAT이라고 하는듯? (gateway도 있고, 라우터도 있고, 스위치도 있고, 공유기도 있고..)
        - Port forwarding을 해서 ip를 변조한 것
    - 대체로 한번 바인딩한 포트에 보내면 그 패킷이 도착함 (이 때 hole punching이 됐다고 함)
- stun server: 외부의 공개된 서버가 바인딩된 포트를 찾아서 알려주는 것
    - 뚫리지 안 뚫릴지는 NAT장수 마음대로!
    - Turn server: 안 뚫리면 relay 해야지..
- WebRTC
    - stun server를 통해서 hole punching 시도하구
    - 안되면 turn server를 통해 돌림!
    - Reliable UDP, hold punching 지원!
- QUIC 프로토콜(표준은 아니지만)
    - Reliable UDP, hold punching 지원!
- hole punching도 UDP 기반
    - 과거에는 구현이 어려웠고 공개가 안되었지만, 지금은 오픈되어 있음

#### 게임 네트워킹의 이해 8 - Deterministic 과 해킹
- Deterministic은 왜 해킹에 취약한가?
    - 구조적으로 Input에 의존하기 때문에
    - 방지: input을 검사
        1. 서버를 이용
            - 중계서버가 심판이 되어서 input 검사
            - 문제: input을 검사하려면 game state, game rule에 대한 정보가 있어야함
                - ex) 벽을 넘어 총을 쐈는지..
                - stateless중계서버이면, 하나의 중계서버로 여러개의 게임을 서비스할 수 잇음
                - state를 갖게되면 같은 중계서버로 어러개의 게임을 다룰수 없어짐
            - FPS는 실제로 보는 캐릭터가 롤백이되므로, 공격자의 시점에서 유리하게 판정되도록 설계되어 있음, 즉 쐈을 떄의 시점에서 맞는 상황
                - 에임핵은 공격쪽에 유리하게 판정되기 떄문에.
                - 이동핵: 이동할 수 있는 거리가 초당 10m면, 어느정도 tolerance를 둠(네트워크 딜레이가 있기 떄문에), 그래서 이동핵은 초당 이동거리를 계속 13m로 되도록 설정  (게임의 오차범위만큼만 이용하는 해킹툴이므로 서버 심판이 검증하기 어려움)
                - 헤드샷핵: 무조건 92%만 나오게 (100%로 하면 심판에 걸림- 어느정도 프로그램에서 인정하는 수준까지만)
            - 해킹을 막는 방법: 
                1. tolerance를 정하는 방법 (하지만, 위에서 말했듯.. 오차 범위가지만 하여 피해감)
                2. [외부해킹(외부툴을 뛰어서), 내부해킹(내부실행파일조작)] 
                    - 외부해킹툴을 못 뛰우게하는 블랙아웃 방식 (nProtect)
                    - 게임 vs 해킹 (해킹이 유리한 이유) 창 vs 방패 (계속 찌르면 뚫림)
                        - 적에게 인질이 클라이언트가 잡혀있음 ( .exe를 어셈블리어로 바꾸어 코드를 읽은뒤 해킹- 익숙해지면 가능한듯)
                        - 방지: 파일사이즈가 변경되었는지 확인
                        - 방지:파일사이즈를 맞췄다면, checksum체크 (hash fucntion을 통해 hash값을 비교. hash값은 해커들이 모르는 곳에 위치)
                        - 방지: 중요한 코드 암호화(실행될 때 디코드)-> 시간이 걸림
        2. 서로가 서로를
        3. 방장이 검사
- 보통 보안 올려도 2주안에 뚫림

#### 게임 네트워킹의 이해 9 - Server Authority
- 서버가 중재자/심판/ 권한을 갖고 있는 형태
- client server 방식
    - 질의/응답 방식
        - 웹서버에서는 클라이언트가 묻고, 서버가 대답하는 방식
- 게임서버(server authority)
    - connection을 유지하는 방식
    - 서버가 때때로 알림도 날림

- MMORPG (동접수!)
    - 이동
        - 클라이언트 클릭 좌표를 보냄, 서버에서 똑같은 해당 캐릭터가 해당 위치로 이동(state)
        - response로 조금씩 이동한 것을 알림! (클라이언트의 관건은 이동을 얼마나 자연스럽게 표현하느냐)
    - 액션
        - 클라이언트에서 스킬 사용 req
        - 서버에서 성공/실패 여부 알림
        - 그리고 이펙트 notify
- 위에 구현은 어렵진 않음
    - 문제는 서버가 로직을 갖고 있어야함
        - 모든 플레이어를 다 컨트롤해야되고, 모든 응답을 해야함
        - 서버 네트워킹쪽보다는 월드를 어떻게 효율적으로 컨트롤하는것이 관건!
        - 10k서버가 꿈- 만명의 유저를 하나의 서버에서 실시간으로
            - 웹서버는 쉽게 가능하지만, 게임서버는 실시간으로 발생하기 떄문에, 클라이언트당 초당 최소 10개, 즉 10000명은 초당 10만개가 날갈수 있어야 실시간 서버라고 할 수 있음

#### 게임 네트워킹의 이해 10 - Socket Programming
- LOL의경우 한방의 들어가는 동접은 10명임
    - 수만개의 게임이 동시에 진행되지만, 하나의 월드의 사람수는 10
- MMORPG의 경우
    - 도시 하나에 사람 수가 수백명 (이 도시를 담당하는 서버가 감당해야하는 connection수가 이미 수백개)
    - 10k server를 핸들링할 수 있는 서버면 훌륭한 서버다!
    - server authority는 구현하는 것보다 massive한 multi 유저들을 어떻게 handling하느냐가 중요
- 소켓프로그래밍 (연결해서 하는 것 소켓에 꼽는 것)
    - 실제 네트워킹은 컴퓨터 하드웨어의 NIC(network interface card- 랜카드)에서 이루어짐
    - OS가 추상화된 HAL을 제공하여 하드웨어를 감춰주므로써, 하드웨어가 어떻게 제공되든 그 윗부분에서 똒같은 interface로 개발할 수 있게 해줌 ( 두 접점을 연결하는 것이 socket - 소켓을 통해 하드웨어와 프로그래밍이 통신) 소켓을 꽂아서 NIC로 들어오는 데이터를 주고 받는 것
    - Socket I/O (Input Output/ Read Write) -> 궁극적으로 추구하는바는 읽고 쓰는 I/O process 것 
        - I/O가 두가지 방식으로 나뉘어짐
            - 동기식(synchronous)
                - read가 완료될때까지 진행 x
                    - 여기서 데이터는 언제 들어올지 모르는데, 데이터가 올 때 까지 기다리는 것.
                    - 문제는 해당 Thread는 데이터가 들어올 때 까지 멈춰있음
                    - 서버에서는 여러개의 conenctino을 동시에 handling해야되므로 서버에 맞지 않음
            - 비동기식(asynchronous)
                - req read() 요청 걸어놓고 데이터가 들어왔든 아니든 넘어가는 것 
                - 데이터가 오면 처리하는 것
                1. Select방식 (Pre-request)
                    - 전화기가 있다면.. 사람들이 자리가 비었나 안 비었나확인! 그리고 딴일하다 또 쳐다보고 쓰나 안쓰나 확인, 언제까지? 다 쓰고 나갈떄까지. 마침 비어있으면 돌아오는 것
                    - Read/Wrtie 요청에서 자리가 비었는지 매번 확인하고, 왔을 때 쓸 수 있어하면 쓰는 것
                    - 일의 주체가 난데, 할 수 있는지 없는지 계속 확인!
                    - 장점: 간단하게 구현 가능

                2. IOCP방식 (post-request) -> windows에서 제공하는 방식
                    - 편지를 보내고 싶은 데.. 우체국에 담당 직원이 앉아있으면, 직원에게 요청, 보내면 알려줌, 그럼 보낸 사람은 택배가 갔는지 실제로 갔는지 상관이 없음. (그냥 보내주세요 요청하고 딴 곳으로 가는 것)
                    - 택배를 받아야하는데, 바구니를 두고, 택배오면 여기에 넣어주세요 하고 딴일보러 가는 것. 택배가 왔으면 담아두는것, 딴일보다가 택배바구니에 와있으면 물건만 찾아가는 것. 바구니가 또 비어있으니깐 또 오면, 채우고
                    - 일의 주체가 내가 아니고 다른사람이 해주는 것. request하고 딴일하고 오는 것(OS가 대신 일을 해줌!)

#### 게임 네트워킹의 이해 11 - MMORPG 서버 구조 1/2
- MMO RPG 서버 구조
    - 유저가 많다(동접수가 많다 = 하나의 서버가 감당해야할 작업량이 많다)
        - 작업량의 기준 Actor 단위 (Player, NPC(+몬스터), controlzone(독우물, 도트뎀, 타워, 본진))
            1. Plyaer
            2. NPC
            3. CZ
            4. 그외
    - 서버할일 (패킷처리+tick 80% / 그외 20%)
        1. 패킷처리(Read, Write)
            - 패킷을 파싱에서 action 처리
        2. Tick 처리
            - 매 프레임에 Actor들의 동작들을 update하는 과정
        3. 그 외 system
            - ex) 경매장(사고/팔기).. 공성정
        - 패킷처리&tick은 Actor수의 비례 => 처리량이 늘어난다
    - 멀티쓰레드가 필수!
        - 좋은 구조를 만드는게 중요

- 정리: MMORPG는 할일이 너무 많음.. 하나의 CPU가 모두 처리하기에는 주어진 시간이 너무 짧음 -> 멀티쓰레드가 필요 -> 효율적인 구조가 필요

- 싱글쓰레드 구조
    - Netowrk I/O
        - Select, IOCP (멀티 쓰레드 형태)
    - --- queue --- (범퍼 역할이 필요)
    - WorkThread1 (싱글 쓰레드)
        - 매 틱마다 읽어서 계산
    - Netowork I/O - Queue - Work Thread
    - 장점: simple, deadlock locking problem, timing 다 필요 없어짐!
    - 단점: 처리 시간이 부족, 처리하는 actor수가 적어짐
- 싱글쓰레드 구조 + alpha (dedicate thread를 넣는 것)
    - Network I/O - workthread1 + DB I/O, 결매장 Thread, 공성전 thread ...
    - 싱글쓰레드의 부하를 어느정도 줄여줌
        - 싱글쓰레드: 패킷처리, Actor update
        - alpha: 나머지 처리
    - 장점: simple한 구조이면서, 어느정도 multithread의 이점도 가져감
- 멀티쓰레드 구조
    - NetowrkIO - Queue, ActorList - WorkThread1,2,3,...
    - 장점: 성능이 올라갈수도 있다?
    - 문제: multithread.. 충돌이 많이 일어남 (locking도 있고..)
        - deadlock 발생가능..
- 멀티쓰레드에서는 구획화(멀티쓰레드를 잘 나누는 것)가 필요

- 싱글쓰레드를 해서 멀티 프로세스해서 나누면 편한듯
    - 하지만 멀티프로세서에서는 서로 interaction(떄리는게 불가)
    - 하나의 월드에서 지역별 다른 프로세스를 가져갈 수 있음
- 멀티쓰레드는.. 공유자원 locking문제 발생
    - seamless서버는 multi thread

#### 게임 네트워킹의 이해 12 - MMORPG 서버 구조 2/3 (싱글프로세스 VS 멀티 프로세스)
- 싱글 프로세스 구조 (가용성이 낮고 비용이 높다)
    - 게임서버가 하나다!
    - 하나의 게임서버로 게임이 서비스된다
        - 각 월드가 하나의 게임서버로 돌아간다 (싱글프로세스)
        - 하나의 월드가 여러개의 게임서버로 돌아간다 (멀티 프로세스)
    - scale up 방식!
        - 하나의 머신이 성능이 올라가면, 프로세스 성능도 올라감
        - 과거에 많이 사용
- 멀티 프로세스 구조 (가용성이 높고 비용이 적다)
    - scale out 방식!
        - 머신성능을 늘리는 것이 아닌, 머신 숫자를 늘리는 것
- 차이
    - scale up
        - 고성능 서버의 가격이 기하급수적으로 증가
    - scale out
        - 같은 머신을 늘려가기때문에, 비용이 직선으로 증가
        - 저성능 머신 여러대가 고성능 머신 한대 보다 싸다
- Availability (가용성)
    - 싱글 프로세스가 죽으면, 해당서버에 접근 불가
        - single point of failure
    - 멀티 프로세스 중 하나가 죽으면, 해당 서버는 아직 살아있음
        - availability가 높다
- scale up -> scale out
- 싱글프로세스 구조가 단순, seamless
    - 멀티 프로세스는 프로세스간 넘어갈 떄 단절 발생.
- 멀티프로세스
    - 관리 비용이 늘어남
    - 버전업되면 배포해야할 개수가 늘어남
    - 서버를 관리해야하는 개수가 늘어남
        - automation이 중요해짐 (Jenkins, kubernetes, docker)
        - DevOps가 생김
    - 지역을 zone방식으로 나누고(수평으로 나누는 것), 경계를 넘어가는 처리가 필요(loading)
        - seamless처리는 복잡
    - 채널로 나누는 형식 (수직으로 나누는 것)
    - 하지만, 나누는 것보다 관리하는게 중요!

#### 게임 네트워킹의 이해 13 - MMORPG 서버 구조 3/3 마지막
-  코어수에 성능이 비례해서 증가하지않음, 증가폭이 줄어듦
    - 쓰레드가 많아지면 서로 자원을 차지하기 위해 싸우기 떄문에
    - 그러므로, 쓰레드를 어떻게 나누느냐가 중요함
    - (싱글쓰레드, 멀티프로세스의 선택이 나쁜선택이 아니게 되는 것)
- 멀티쓰레드에서 중요한것: 자원을 어떻게 나눌 것이냐.
    1. 무식하게 한다 (알아서 하게) => Hell
        - 성능이 떨어짐
        - Deadlock 상황 발생
        - race condition (누가 먼저 차지하느냐) =>  timing issue 생김
    2. Actor 기준으로 나누는 방식
        - AKKa방식 (scala에서 제공하는 framework이름)
            - Actor가 기준
            - Actor가 각자의 쓰레드를 가지고 있음
            - Actor간의 통신은 message로
                - 각 Actor마다 queue가 있음
                - goLang에서 제공하는 channel이 message queue임
            - 이상적으로: Lock이 필요없고, 자원이 공유되지 않음(Actor는 Actor만의 고유한 자원을 가짐)
            - 현실: A가 B의 상태를 조회해야함 (상대의 체력에 %댐)
                - HP라는 자원이 공유됨 (Lock이 필요한 상황이 생김)
                - 메시지로 getHP를 한 후, HP값을 받고, deal을 계산하여 메시지를 보내는 형태 (Lock이 필요 없음)
                    - 코딩 복잡도가 올라감, 비동기 적이라, 실제 HP가 ㅇ다를 수 있음 (timing issue가 생김)
    3. System 기준으로 나누는 것
        - ECS - Entitiy Component System
            - 캐릭터(entity)가 어떤 토큰을 갖고 있냐에 따라 (Flying, attack, talk)
            - 갖고있는 component에 따라 성격이 달라짐!
        - entity(방), component(각 기능별 data)
            - component는 data지 function 및 기능이 아님 ( class가 아님)
                - struct구조 
                - 기능은? 누가 갖고 있냐..? -> System이 가지고 있음 (flying system, attack system)
                    - system은 기능만 담당하고, data는 component에서 가져옴
        - entity는 component를 가지고 있고, 어떤 component를 가지고 있느냐에 다라 성격이 달라짐
        - component는 오로지 데이터만 갖고 있고 기능은 없음
        - system 기능을 가능케 함! 기능만 담당하고 데이터는 갖고 있지 않음!
        - 장점: 서로간의 역할이 분산되었기 때문에, 역할이 분명함!
        - MVC모델의 게임버전
            - Model -> 데이터 
            - View -> 화면
            - Controller -> 기능 
            - 데이터와 기능을 가지고 화면에 나타내는 것 
        - ECS는 시스템간 서로 분리시켜 시스템기준으로 쓰레드를 나눌 수 있음
        - 장점
            1. 확장이 쉬워짐
                - NPC건 PC건 monster건 다 entity임. 어떤 컴포넌트를 가지냐에 따라 성격이 달라짐
            2. 데이터 로컬리티(locality)가 좋아짐
                - ex) RenderSystem 그림을 그리려면 DrawComponent를 가져와야 함
                    - for each DrawComponent; Draw(DrawComponent.Image)
                    - DrawComponet의 이미지들이 하나의 메모리 영역에 모여있을 수 있음 (array 형태로) => data locality 
                        - 붙어있으면, L4에 올라갈 때 같이 올라갈 확률이 높아짐.
                - ECS구조를 가져가면, component들은 데이터들만 갖고 있기때문에 같은 컴포넌트들을 array형태로 묶을 수 있음!
                    - 한번에 캐시라인에 올라가서 성능이 발라짐
            - 현실: CombatSystem, BuffSystem
                - 시스템간 상호 통신도 가능해야되고, system과 component의 관계가 1대 다가 됨
                - c3가 A system B system에 둘다 연결되어있을 때 A가 먼저사용중이면 B system은 기다려야함
                - A가 B에 물어봐야하는 상황이 생김
            - 문제점: S 1:N C, System과 system간의 인터랙션이 일어날 수 있다.
                -> 복잡도가 올라가고 타이밍 이슈가 생김